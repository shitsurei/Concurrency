package Chapter2;

/**
 * 08
 * 锁膨胀
 * 如果在尝试轻量级加锁的过程中，CAS操作无法成功，就有可能出现了锁膨胀
 * 锁膨胀是指当一个线程试图给某个对象加轻量级锁时发现已经有其他线程对该对象加了轻量级锁（CAS失败，出现竞争），从而进入重量级锁过程
 * <p>
 * 锁膨胀流程：
 * 1 为锁对象申请Monitor对象
 * 2 将Monitor对象的Owner指针指向持有锁对象的线程（通过原本锁对象对象头的Mark Word获取线程地址）
 * 3 将锁对象的Mark Word修改为重量级锁状态，即【30bit的指向Monitor对象的指针和2bit的加锁状态10】
 * 4 将出现竞争的线程进行阻塞（BLOCKED状态），连接到Monitor对象的EntryList阻塞队列中
 * 解锁过程：
 * 1 原本持有锁对象轻量级锁的线程执行完同步代码块之后尝试CAS解锁失败，进入重量级锁解锁过程
 * 2 原线程通过锁对象的Mark Word指针找到Monitor对象，清除Monitor对象的Owner指针，并唤醒阻塞队列中的其他线程
 * 3 之后对该锁对象的加锁解锁流程总是走重量级锁的加锁解锁流程
 *
 * 自旋优化
 * 【在多核CPU的环境中，单核CPU中自旋是没有意义的】
 * 锁对象正在被线程持有，而另一个线程想要获取该对象时，不直接陷入阻塞，而是执行几次自旋重试的过程，称为自旋优化
 * 这样做的好处在于节省因为线程阻塞和唤醒导致的线程上下文切换的系统开销
 * JDK7以后自旋优化功能改为自适应，无法人为干预
 */
public class LockInflation {
}
