# Concurrency
> Java并发编程总结
## 线程
### 栈与栈帧
1. 栈内存的使用者是线程，每个线程启动后虚拟机就为其分配一块栈内存
2. 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存，栈帧中保存着当前方法执行的局部变量表、操作数栈、锁记录、返回地址
3. 每个线程只能有一个活动的栈帧，对应着当前执行的方法，并且每个线程都有自己的程序计数器，标识该线程执行到了那一行代码（指令）
### 线程上下文切换
1. 切换场景：
    1. 线程的时间片用完
    2. 发生GC（CMS和G1的并发标记和清理阶段支持与用户线程同时运行）
    3. 有更高优先级的线程需要运行（抢占式的优先级调度算法）
    4. 前三种是被动切换，还有线程主动切换——发生系统调用：sleep、lock、synchronized、yield等等
2. 发生上下文切换时需要由操作系统保存当前线程运行的状态，并恢复另一个线程的运行环境（即由程序计数器来完成），因此上下文切换的系统开销决定了频换的上下文切换会影响性能（故线程数超过CPU核心数时得不偿失）
### 线程的状态
1. Java进程是需要等待所有线程执行结束才会停止
2. **守护线程**是一种特殊的线程，只要其他非守护线程执行结束，守护线程也会强制结束。应用包括垃圾回收器线程，Tomcat中的Acceptor和Poller线程
3. 进程有五种状态，分别是初始态、就绪态、运行态、阻塞态和终止态；Java中的Thread类将线程分为六种状态，分别是NEW、RUNNABLE（涵盖了操作系统层面的就绪态、运行态和阻塞态）、BLOCKED、WAITING、TIMED_WAITING【这三种阻塞状态是Java中的定义】、TERMINATED
4. 线程状态转换的情况：
    1. NEW转为RUNNABLE：调用线程对象的start方法，启动线程
    2. RUNNABLE和WAITING之间相互装换：wait和notify方法，join同步方法，park和unpark方法
    3. RUNNABLE和TIMED_WAITING之间相互装换：带参数的wait和notify方法，带参数的join方法，带参数的parkNanos和unpark方法，sleep方法
    4. RUNNABLE转为BLOCKED：等待中的线程被唤醒或竞争锁失败
    5. RUNNABLE转为TERMINATED：线程运行结束
## 锁
### 重量级锁和管程
### 轻量级锁
### 偏向锁
## 设计模式
### 两阶段终止
### 保护性暂停
### 生产者消费者
## 无锁并发
### CAS
1. CAS是基于乐观锁的思想：认为不会有其他线程来对资源加锁，因此**不对资源加锁**；即使其他线程修改了变量，也可以通过自旋的方式等待锁被释放（需要在多CPU环境下才能发挥效力）
2. synchronized是基于悲观锁的思想：认为会有其他线程来争抢资源，因此预先对资源加锁，可以防止其他线程对共享变量的访问，但是加锁开销会降低程序运行效率
3. CAS体现的是无锁并发、无阻塞并发（因为没有synchronized，所以线程不会陷入阻塞）