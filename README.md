# Concurrency
> Java并发编程总结
## 线程
### 栈与栈帧
1. 栈内存的使用者是线程，每个线程启动后虚拟机就为其分配一块栈内存
2. 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存，栈帧中保存着当前方法执行的局部变量表、操作数栈、锁记录、返回地址
3. 每个线程只能有一个活动的栈帧，对应着当前执行的方法，并且每个线程都有自己的程序计数器，标识该线程执行到了那一行代码（指令）
### 线程上下文切换
1. 切换场景：
    1. 线程的时间片用完
    2. 发生GC（CMS和G1的并发标记和清理阶段支持与用户线程同时运行）
    3. 有更高优先级的线程需要运行（抢占式的优先级调度算法）
    4. 前三种是被动切换，还有线程主动切换——发生系统调用：sleep、lock、synchronized、yield等等
2. 发生上下文切换时需要由操作系统保存当前线程运行的状态，并恢复另一个线程的运行环境（即由程序计数器来完成），因此上下文切换的系统开销决定了频换的上下文切换会影响性能（故线程数超过CPU核心数时得不偿失）
### 线程的状态
1. Java进程是需要等待所有线程执行结束才会停止
2. **守护线程**是一种特殊的线程，只要其他非守护线程执行结束，守护线程也会强制结束。应用包括垃圾回收器线程，Tomcat中的Acceptor和Poller线程
1. 进程有五种状态，分别是初始态、就绪态、运行态、阻塞态和终止态；Java中的Thread类将线程分为六种状态，分别是NEW、RUNNABLE（涵盖了操作系统层面的就绪态、运行态和阻塞态）、BLOCKED、WAITING、TIMED_WAITING【这三种阻塞状态是Java中的定义】、TERMINATED
